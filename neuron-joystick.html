<link rel="import" href="../polymer/polymer.html">
<script type="text/javascript" src="../d3/d3.min.js"></script>

<dom-module id="neuron-joystick">
	<style>
		:host{
			display: block;
			position: relative;
		}

		:host #disconnectLayer {
			position: absolute;
			width: 100%;
			height: 100%;
			top: 0;
			left: 0;
			display: block;
			color: gray;
			border-radius: 100%;
			background: rgba(150, 150, 150, 0.33);
		}

		:host #disconnectLayer.connected {
			display: none;
		}

		#map { background:transparent;}

	</style>
	<template>
		<div id="disconnectLayer" class$="{{state}}"></div>
		<svg id="map" version="1.1" viewBox="-100 -100 200 200">
			<!--			<image id="mapImage" width="100%" height="100%" x="-100" y="-100" xlink:href="bower_components/neuron-joystick/joystick.svg"></image>-->

			<circle cx="0" cy="0" r="98" fill="white" stroke="black" stroke-width="1"></circle>
			<rect width="0.5" height="196" x="0" y="-98" fill="gray"></rect>
			<rect width="196" height="0.5" x="-98" y="1" fill="gray"></rect>

			<circle id="handle" cx="0" cy="0" r="20" fill="lightgray" stroke="gray" stroke-width="1"></circle>
		</svg>


		<div id="neurons">
			<content id="content"></content>
		</div>

	</template>
</dom-module>

<script type="text/javascript">
	Polymer({
		is: 'neuron-joystick',
		properties: {
			angle: { notify: true },
			speed: { notify: true },
			state: { value: 'disconnected', notify: true }
		},

		attached: function () {

//01ffff
			this.state = 'disconnected';

			var neurons = null;
			var neuronsShadow = this.$.content.getDistributedNodes();
			var neuronsShady = this.$.neurons.children;

			if(neuronsShadow.length > 0) neurons = neuronsShadow;
			else neurons = neuronsShady;

			for (var i = 0; i < neurons.length; i++) {
				if (neurons[i].attributes && neurons[i].attributes['role']) {
					switch (neurons[i].attributes['role'].value) {
						case 'speed':
							this._speedNeuron = neurons[i];
							neurons[i].frequency = 10;
							break;
						case 'angle':
							this._angleNeuron = neurons[i];
							neurons[i].frequency = 10;
						break;
					}
				}
			}

			var that = this;

			this._speedNeuron.addEventListener('state-changed',this.updateState.bind(this));
			this._angleNeuron.addEventListener('state-changed',this.updateState.bind(this));
		},

		ready: function () {
			this.angle = 0.5;
	       		this.speed = 0;
			this.x = 0;
			this.y = 0;
			this._frameRequested = false;
			this._then = Date.now();
			this._now;
			this._fps = 60;
			this._interval = 1000/this._fps;
			this.initJoystick();
			this.redraw();
		},

		initJoystick: function () {
			var that = this;
			var dragBehavior = d3.behavior.drag().on('drag', function () {
				that.setHandle(d3.event.x, d3.event.y);
			}).on('dragstart', function () {
				that._speedNeuron.setAutoSend(true);
				that._angleNeuron.setAutoSend(true);
			}).on('dragend', function () {
				that._speedNeuron.setAutoSend(false);
				that._angleNeuron.setAutoSend(false);
				that.setHandle(0, 0);
			});
		      	d3.select(this.$.handle).call(dragBehavior);
	      	},

		setHandle: function (x, y) {
			this.x = Math.min(Math.max(x, -100), 100);
			this.y = Math.min(Math.max(y, -100), 100);
			this._frameRequested = true;
			this.computeAction();
	   	},

		redraw: function(){
			var that = this;
			requestAnimationFrame(function() {
				that.redraw();
			});

			this._now = Date.now();
			var delta = this._now - this._then;

			if(this._frameRequested && delta > this._interval){
				this._then = this._now - (delta % this._interval);
				this.updateDisplay();
				this._frameRequested = false;
			}
		},

		computeAction: function () {
			var x = this.x;
			var y = this.y;
			this.speed = Math.min(Math.max(y / -100, -1), 1);
			this.angle = Math.min(Math.max((x + 100) / 200, 0), 1);
			this.updateNeurons();
	      	},

		updateDisplay: function () {
		 	var that = this;
			requestAnimationFrame(function () {
				d3.select(that.$.handle).attr('transform', 'translate('+that.x+','+that.y+')');
		       });
	       },

		updateNeurons: function () {
		       if (this._speedNeuron.isConnected())
			       this._speedNeuron.send(0, this.speed);
		       if (this._angleNeuron.isConnected())
			       this._angleNeuron.send(0, this.angle);
	       },

		updateState: function(){
			this.state = (this._speedNeuron && this._speedNeuron.state === 'connected' && this._angleNeuron && this._angleNeuron.state === 'connected') ? 'connected' : 'disconnected';
		}

	});
</script>

<link rel="import" href="../polymer/polymer.html">
<script type="text/javascript" src="../d3/d3.min.js"></script>

<dom-module id="neuron-joystick">
  <style>
			:host{
				display: block;
				position: relative;
			}

			:host #disconnectLayer{
				position: absolute;
				width: 100%;
				height: 100%;
				top: 0;
				left: 0;
				display: block;
				background: rgba(255,255,255, 0.5);
				color: gray;
			}

		</style>
  <template>
		<template is="dom-if" if="{{computeDisabled(_angleNeuron.state, _speedNeuron.state)}}"><div id="disconnectLayer"></div></template>
		<svg id="map" version="1.1" viewBox="-100 -100 200 200">
			<image id="mapImage" width="100%" height="100%" x="-100" y="-100" xlink:href="bower_components/neuron-joystick/joystick.svg"></image>

			<circle id="handle" cx="0" cy="0" r="20" stroke="black" stroke-width="3" fill="gray"></circle>
		</svg>


		<div id="neurons">
			<content></content>
		</div>

	</template>
</dom-module>
<script type="text/javascript">
  Polymer({
    is: 'neuron-joystick',
    properties: {
      angle: { notify: true },
      speed: { notify: true }
    },
    attached: function () {
      var neurons = this.$.neurons.children;
      for (var i = 0; i < neurons.length; i++) {
        if (neurons[i].attributes && neurons[i].attributes['role']) {
          switch (neurons[i].attributes['role'].value) {
          case 'speed':
            this._speedNeuron = neurons[i];
            neurons[i].autosend = true;
            neurons[i].frequency = 15;
            break;
          case 'angle':
            this._angleNeuron = neurons[i];
            neurons[i].autosend = true;
            neurons[i].frequency = 15;
            break;
          }
        }
      }
    },
    ready: function () {
      this.angle = 0.5;
      this.speed = 0;
      this.x = 0;
      this.y = 0;
      this._frameRequested = false;
      this.initJoystick();
    },
    initJoystick: function () {
      var that = this;
      var dragBehavior = d3.behavior.drag().on('drag', function () {
        that.setHandle(d3.event.x, d3.event.y);
      }).on('dragend', function () {
        that.setHandle(0, 0);
      });
      d3.select(this.$.handle).call(dragBehavior);
    },
    setHandle: function (x, y) {
      this.x = Math.min(Math.max(x, -100), 100);
      this.y = Math.min(Math.max(y, -100), 100);
      this.updateDisplay();
      this.computeAction(this.x, this.y);
    },
    computeAction: function (x, y) {
      this.speed = Math.min(Math.max(y / -100, -1), 1);
      this.angle = Math.min(Math.max((x + 100) / 200, 0), 1);
      this.updateNeurons();
    },
    updateDisplay: function () {
      if (this._frameRequested)
        return;
      var that = this;
      this._frameRequested = true;
      requestAnimationFrame(function () {
        d3.select(that.$.handle).attr('cx', that.x).attr('cy', that.y);
        that._frameRequested = false;
      });
    },
    updateNeurons: function () {
      if (this._speedNeuron.isConnected())
        this._speedNeuron.send(0, this.speed);
      if (this._angleNeuron.isConnected())
        this._angleNeuron.send(0, this.angle);
    },
    computeDisabled: function (_angleNeuronState, _speedNeuronState) {
      return _speedNeuronState === 'disconnected' || _angleNeuronState === 'disconnected' ? true : false;
    }
  });
</script>
